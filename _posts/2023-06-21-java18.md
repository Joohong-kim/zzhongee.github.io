---
layout: single
title: "Network"
show_date: true
categories: coding
tag: [Java, blog, jekyll]
author_profile: false
toc: true
---

## 1. **네트워크 기본 개념**

- **서버(Server):** 사용자들에게 서비스를 제공하는 컴퓨터를 말합니다.

- **클라이언트(Client):** 서버에게 서비스를 요청하고 사용하는 컴퓨터를 말합니다.

- **DNS (Domain Name System):** 숫자 대신 기호를 사용하는 주소를 관리하는 시스템입니다. 주로 53포트를 사용합니다.

- **DNS 서버:** 기호 주소를 숫자 주소로 변환해주는 서버로, 도메인 이름을 IP 주소로 매핑해줍니다.

- **URL (Uniform Resource Locator):** 인터넷 상의 자원을 나타내는 약속입니다. 파일이나 데이터베이스와 같은 자원에 대한 주소를 지정하는 방법입니다. 프로토콜 이름, 호스트 이름, 파일 이름, 포트 번호 등으로 구성됩니다. 예를 들면, "http://www.naver.com/index.html:80"과 같습니다.

- **IP 주소란?:** 인터넷 상에서 장치간 통신을 위해 장치를 식별하는 주소입니다.

- **IPv4 vs. IPv6:**

  - **IPv4:** 현재 일반적으로 사용되는 IP 주소 형식으로, 32비트로 구성되며 약 43억개의 주소를 가집니다. [0-255].[0-255].[0-255].[0-255]와 같이 10진수 4개를 점으로 구분하여 표기합니다. 예를 들면, "192.168.0.97"입니다. 특정 IP는 특별 용도로 예약되어 사용되며, 예를 들면 "127.0.0.1"은 로컬 호스트(루프백) 주소인 "localhost"를 가리킵니다.

  - **IPv6:** IPv4에서의 IP 부족 현상을 해결하기 위한 방법으로, 128비트 (16바이트)로 구성됩니다. IPv4에 비해 주소 공간이 매우 크며, (약 43억 _ 43억 _ 43억 \* 43억) 개의 주소를 가집니다.

- **사설 IP:** 내부망에서만 한정적으로 사용되는 IP 주소입니다. 내부에서만 사용되기 때문에 네트워크별로 중복 가능하며, 특별한 용도로 예약되어 사용됩니다.

- **포트:** 호스트 내에서 실행되고 있는 프로세스를 구분하기 위한 16비트의 논리적 할당입니다. 0부터 65535까지의 범위를 가지며, 호스트의 IP가 집주소에 해당하는 개념이라면 포트는 방 번호에 해당합니다. 호스트의 IP가 컴퓨터를 찾기위한 정보라면 포트는 프로그램에 해당합니다. 대표적인 포트로는 80번 포트가 있으며, 이는 HTTP 웹 서비스에 사용됩니다.

- **TCP (Transmission Control Protocol):** 신뢰성이 높은 프로토콜로, 오류 발생 시 재전송을 통해 데이터의 신뢰성을 보장합니다. 연결형 프로토콜이며, 통신 과정에서 연결을 유지해야 합니다. 통신 상대가 많은 경우 시스템 부하가 높을 수 있습니다. 전송 데이터 크기에 제한이 없습니다. 파일 전송과 같이 신뢰성이 필요한 서비스에 주로 사용되며, 전화 통신과 유사한 개념입니다.

- **UDP (User Datagram Protocol):** 신뢰성이 낮은 프로토콜로, 오류 발생 시 데이터그램(전달 데이터)을 삭제합니다. 비연결형 프로토콜이며, 통신 과정에서 연결을 유지할 필요가 없어 시스템 부하가 낮습니다. 전송 데이터의 크기는 65,536 바이트(헤더 포함)로 초과할 경우에는 나누어 전송됩니다. 실시간성과 같은 성능이 중요한 서비스에 주로 사용되며, 우편(소포) 통신과 유사한 개념입니다.

## 2. 상호작용

네트워크 상에서 서버와 클라이언트 간의 상호 작용은 다음과 같은 단계로 이루어집니다.

1. 서버가 시작됩니다.
2. 클라이언트가 연결을 요청합니다.
3. 서버는 ServerSocket 객체를 생성하고, 연결 요청을 받습니다.
4. 서버는 클라이언트와의 연결을 위해 소켓을 생성하고 연결 준비를 합니다.
5. 클라이언트의 출력 스트림과 서버의 입력 스트림이 연결됩니다.
6. 클라이언트의 입력 스트림과 서버의 출력 스트림이 연결됩니다.

상호 대화 단계에서는 read()와 write()를 사용하여 데이터를 주고받습니다. 통신이 완료되면 종료 단계에서는 close()를 사용하여 연결을 종료합니다.

## 3. **BufferedWriter와 FileWriter:**

BufferedWriter는 FileWriter 없이 사용할 수 없으며, FileWriter에 의존합니다. BufferedWriter는 버퍼링된 문자 출력 스트림으로, FileWriter를 감싸서 사용합니다. BufferedWriter는 데이터를 버퍼에 쌓아놓고 효율적으로 파일에 쓰기 작업을 수행하기 때문에 성능이 개선됩니다.

BufferedWriter는 FileWriter에 비해 메모리를 더 사용하므로 대량의 데이터를 처리할 때 효과적입니다. FileWriter는 텍스트 데이터를 파일에 쓰는 데 사용되는 문자 출력 스트림입니다. FileWriter는 데이터를 즉시 파일에 쓰기 때문에 작업이 끝날 때까지 데이터를 버퍼링하지 않습니다.

따라서, 일반적으로 BufferedWriter를 FileWriter와 함께 사용하여 효율적인 파일 쓰기 작업을 수행할 수 있습니다. BufferedWriter는 FileWriter에 대한 버퍼링 기능을 제공하여 파일 쓰기 속도를 향상시킵니다.

예를 들어, 다음과 같은 코드를 사용하여 BufferedWriter와 FileWriter를 함께 사용할 수 있습니다:

```java
try {
    FileWriter fileWriter = new FileWriter("filename.txt");
    BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

    bufferedWriter.write("Hello, World!");
    bufferedWriter.newLine();
    bufferedWriter.write("This is an example of using BufferedWriter with FileWriter.");

    bufferedWriter.close();
    fileWriter.close();
} catch (IOException e) {
    e.printStackTrace();
}
```

위의 코드에서는 FileWriter를 생성한 후에 BufferedWriter로 감싸서 사용합니다. BufferedWriter의 write() 메서드를 사용하여 데이터를 파일에 쓰고, newLine() 메서드를 사용하여 새 줄로 이동합니다. 마지막으로 bufferedWriter와 fileWriter를 닫아서 파일에 대한 자원을 해제합니다.

이렇게 함으로써 BufferedWriter와 FileWriter를 함께 사용하여 파일에 데이터를 쓸 수 있습니다.

<!-- {: .notice--danger}

<div class="notice--success">
멀티스레드는 여러 개의 스레드를 동시에 실행하여 병렬 처리와 성능 향상을 이룰 수 있습니다. 작업을 분할하고 각각의 스레드가 독립적으로 작업을 처리하므로 전체 작업 시간을 단축시킬 수 있습니다. 각 스레드는 독립적으로 실행되기 때문에 하나의 스레드에서 오류가 발생해도 다른 스레드는 영향을 받지 않아 안정적인 실행 환경을 제공할 수 있습니다. 또한, 멀티스레드는 다양한 작업을 동시에 처리할 수 있는 유연성을 제공하므로 다양한 비동기적 작업에 적합합니다. 하지만 멀티스레드는 스레드 간의 동기화와 관리, 경합 조건 및 교착상태 등의 문제에 대한 고려와 조치가 필요합니다. 따라서 코드의 복잡성이 증가하고 디버깅이 어려울 수 있으며, 스레드 간의 동기화 오버헤드와 경합 조건에 의한 성능 저하 가능성도 있습니다. 적절한 설계와 관리를 통해 멀티스레드의 장점을 최대한 활용하고 문제를 예방해야 합니다.

</div> -->
